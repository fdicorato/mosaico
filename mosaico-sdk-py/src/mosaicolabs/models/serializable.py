"""
Serialization and Registry Module.

This module defines the `Serializable` base class, which serves as the root for all
specific ontology data types (e.g., IMU, Image, Odometry).

It implements a **Registry/Factory Pattern**:
1.  **Auto-Registration**: Any subclass defined in the code is automatically registered
    via `__init_subclass__`.
2.  **Factory Creation**: The `._create()` method instantiates specific subclasses based
    on a string tag.
3.  **Query Capability**: It injects query proxies allowing users to write `IMU.Q.acc_x > 0`.
"""

from typing import Optional, Type, Dict, List, ClassVar
import pyarrow as pa

from mosaicolabs.enum import SerializationFormat
from mosaicolabs.helpers import camel_to_snake

from .base_model import BaseModel

from .query.generation.api import _QueryProxyMixin
from .query.expressions import _QueryCatalogExpression
from .internal.pyarrow_mapper import PyarrowFieldMapper
from .internal.helpers import _fix_empty_dicts


# --- Private Registry ---
# Global dictionary mapping string tags (e.g., "imu") to class types.
_SENSOR_REGISTRY: Dict[str, Type["Serializable"]] = {}


class Serializable(BaseModel, _QueryProxyMixin):
    """
    The base class for all Mosaico ontology data payloads.

    This class serves as the root for every sensor and data type in the Mosaico ecosystem.
    By inheriting from `Serializable`, data models are automatically compatible with the platform's storage,
    querying, and serialization engines.

    ### Dynamic Attributes Injection
    When you define a subclass, several key attributes are automatically managed or required.
    Understanding these is essential for customizing how your data is treated by the platform:

    * **`__serialization_format__`**:
        Determines the batching strategy and storage optimization.
        * **Role**: It tells the `SequenceWriter` whether to flush data based on byte size (optimal for heavy data like `Images`) or record count (optimal for light telemetry like `IMU`).
        * **Default**: `SerializationFormat.Default`.

    * **`__ontology_tag__`**:
        The unique string identifier for the class (e.g., `"imu"`, `"gps_raw"`).
        * **Role**: This tag is used in the global registry to reconstruct objects from raw platform data.
        * **Generation**: If not explicitly provided, it is auto-generated by converting the class name from `CamelCase` to `snake_case`.

    * **`__class_type__`**:
        A reference to the concrete class itself.
        * **Role**: Injected during initialization to facilitate polymorphic instantiation and safe type-checking when extracting data from a [`Message`][mosaicolabs.models.Message].

    ### Requirements for Custom Ontologies
    To create a valid custom ontology, your subclass must:

    1.  Inherit from `Serializable`.
    2.  Define a `__msco_pyarrow_struct__` attribute using `pa.StructType` to specify the physical schema.
    3.  Define the class fields (using Pydantic syntax) matching the Arrow structure.

    Tip: Automatic Registration
        Any subclass of `Serializable` is automatically registered in the global Mosaico registry upon definition. This enables the use of the factory methods and the `.Q` query proxy immediately.
    """

    # --- Factory/Metadata Attributes ---

    # Defaults to 'Default' SerializationFormat.
    # Heavy data types (like Images) should override this to 'Image' (Bytes-based batching).
    __serialization_format__: ClassVar[SerializationFormat] = (
        SerializationFormat.Default
    )

    # Unique tag. If None, it is auto-generated from the class name (CamelCase -> snake_case).
    __ontology_tag__: ClassVar[Optional[str]] = None

    # Reference to the actual subclass.
    __class_type__: ClassVar[Type["Serializable"]]

    def __init_subclass__(cls, **kwargs):
        """
        Registers the subclass and injects query capabilities.

        This method is called automatically when a new ontology class is defined.
        It performs schema validation, tag generation, and global registration.

        Raises:
            AttributeError: If `__msco_pyarrow_struct__` is missing or invalid.
            ValueError: If the generated or assigned tag collides with an existing one.
        """
        super().__init_subclass__(**kwargs)

        # Schema Validation
        if not hasattr(cls, "__msco_pyarrow_struct__") or not isinstance(
            cls.__msco_pyarrow_struct__, pa.StructType
        ):
            raise AttributeError(
                "Classes for Data Ontology must have a pyarrow '__msco_pyarrow_struct__' attribute."
            )

        # This ensures that names match exactly before registration
        cls._validate_schema_alignment()

        # Tag Generation
        tag = cls.__ontology_tag__ or camel_to_snake(cls.__name__)
        cls.__ontology_tag__ = tag
        cls.__class_type__ = cls

        # Registration
        if tag in _SENSOR_REGISTRY:
            raise ValueError(
                f"Duplicate ontology tag '{tag}' detected "
                f"(already registered for '{_SENSOR_REGISTRY[tag].__name__}')"
            )
        _SENSOR_REGISTRY[tag] = cls

        # Query Proxy Injection
        # Enables syntax like: MySensor.Q.field_name > value
        _QueryProxyMixin._inject_query_proxy(
            cls,
            mapper=PyarrowFieldMapper(),
            query_expression_type=_QueryCatalogExpression,
            query_prefix=None,
        )

    # --- Factory Methods ---

    @classmethod
    def _validate_schema_alignment(cls):
        """
        Ensures a 1:1 mapping between Pydantic fields and the PyArrow struct schema.
        """
        # Get the names from the PyArrow struct
        pa_field_names = set(f.name for f in cls.__msco_pyarrow_struct__)

        # Exclude the Serializable inner fields + the Query Proxy
        ignore_fields = set(_QueryProxyMixin.__annotations__)

        python_fields = set()
        for base in cls.mro():
            # Collect all annotations but filter out internal Mosaico or Python dunders
            annotations = getattr(base, "__annotations__", {})
            python_fields.update(
                k
                for k in annotations.keys()
                if k not in ignore_fields and not k.startswith("_")
            )

        # Perform the Symmetric Difference check
        discrepancies = pa_field_names ^ python_fields
        if discrepancies:
            raise TypeError(
                f"Schema mismatch in ontology class '{cls.__name__}':\n"
                f" - Fields in PyArrow but missing or renamed in class fields: {list(discrepancies)}\n"
                f"Hint: Every field in the __msco_pyarrow_struct__ must have a "
                f"corresponding type-hinted attribute in the class or its mixins."
            )

    @classmethod
    def _create(cls, tag: str, *args, **kwargs) -> "Serializable":
        """
        Factory method to instantiate a specific ontology object by its tag.

        Args:
            tag: The unique ontology identifier (e.g., "imu", "gps").
            *args: Positional arguments for the subclass constructor.
            **kwargs: Keyword arguments for the subclass constructor.

        Returns:
            An instance of the requested `Serializable` subclass.

        Raises:
            ValueError: If the tag is not found in the global registry.
        """
        if tag not in _SENSOR_REGISTRY:
            raise ValueError(
                f"No ontology registered with tag '{tag}'. "
                f"Available tags: {list(_SENSOR_REGISTRY.keys())}"
            )

        # Clean up potential artifacts from Parquet deserialization (e.g., None as empty structs)
        fixed_kwargs = _fix_empty_dicts(kwargs) if kwargs else {}

        # Instantiate
        return _SENSOR_REGISTRY[tag](*args, **fixed_kwargs)

    # --- Registry Helper Methods ---

    @classmethod
    def _list_registered(cls) -> List[str]:
        """Returns a list of all currently registered ontology tags."""
        return list(_SENSOR_REGISTRY.keys())

    @classmethod
    def _is_registered(cls, tag: str) -> bool:
        """
        Checks if a tag is registered.

        Args:
            tag (str): The tag to check.

        Returns:
            bool: True if registered.
        """
        return tag in _SENSOR_REGISTRY.keys()

    @classmethod
    def _get_class_type(cls, tag: str) -> Optional[Type["Serializable"]]:
        """
        Retrieves the concrete Python class type associated with a specific tag.

        Args:
            tag: The unique ontology identifier.

        Returns:
            The Python class type if found, otherwise `None`.
        """
        if not cls._is_registered(tag):
            return None
        return _SENSOR_REGISTRY[tag].__class_type__

    @classmethod
    def _get_ontology_tag(
        cls, class_type_name: str, case_sensitive: bool = True
    ) -> Optional[str]:
        """
        Reverse lookup: finds a tag given a class name.

        Args:
            class_type_name (str): The name of the class (e.g., "IMU").
            case_sensitive (bool): Whether to perform case-sensitive matching.

        Returns:
            Optional[str]: The tag, or None if the class is not found.
        """
        class_type_name_cmp = (
            class_type_name if case_sensitive else class_type_name.lower()
        )

        return next(
            (
                sens.__ontology_tag__
                for sens in _SENSOR_REGISTRY.values()
                if (
                    sens.__class_type__.__name__
                    if case_sensitive
                    else sens.__class_type__.__name__.lower()
                )
                == class_type_name_cmp
            ),
            None,
        )

    @classmethod
    def is_registered(cls) -> bool:
        """
        Checks if a class is registered.

        Returns:
            bool: True if registered.
        """
        if not hasattr(cls, "__ontology_tag__"):
            return False
        return cls.__ontology_tag__ in _SENSOR_REGISTRY.keys()

    @classmethod
    def ontology_tag(cls) -> str:
        """
        Retrieves the unique identifier (tag) for the current ontology class, automatically generated during class definition.

        This method provides the string key used by the Mosaico platform to identify and route
        specific data types within the ontology registry. It abstracts
        away the internal naming conventions, ensuring that you always use the correct
        identifier for queries and serialization.

        Returns:
            The registered string tag for this class (e.g., `"imu"`, `"gps"`).

        Raises:
            Exception: If the class was not properly initialized via `__init_subclass__`.

        Hint: **Practical Application: Topic Filtering**
            This method is particularly useful when constructing [`QueryTopic`][mosaicolabs.models.query.builders.QueryTopic]
            requests. By using the convenience method [`QueryTopic.with_ontology_tag()`][mosaicolabs.models.query.builders.QueryTopic.with_ontology_tag],
            you can filter topics by data type without hardcoding strings that might change.

            Example:
                ```python
                from mosaicolabs import MosaicoClient, Topic, IMU, QueryTopic

                with MosaicoClient.connect("localhost", 6726) as client:
                    # Filter for a specific data value (using constructor)
                    qresponse = client.query(
                        QueryTopic(
                            Topic.with_ontology_tag(IMU.ontology_tag()),
                        )
                    )

                    # Inspect the response
                    if qresponse is not None:
                        # Results are automatically grouped by Sequence for easier data management
                        for item in qresponse:
                            print(f"Sequence: {item.sequence.name}")
                            print(f"Topics: {[topic.name for topic in item.topics]}")
                ```
        """
        if not hasattr(cls, "__ontology_tag__") or cls.__ontology_tag__ is None:
            raise Exception(
                f"class '{cls.__name__}' has no '__ontology_tag__' attribute. Initialization failed."
            )
        return cls.__ontology_tag__
